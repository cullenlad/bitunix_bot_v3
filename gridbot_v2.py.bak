import os, time, math, logging, requests, json, threading
from datetime import datetime
from dotenv import load_dotenv

load_dotenv("/opt/bitunix-bot/.env")

BASE_URL = "https://fapi.bitunix.com"
API_KEY = os.getenv("BITUNIX_API_KEY")
API_SECRET = os.getenv("BITUNIX_API_SECRET")
SYMBOL = os.getenv("SYMBOL", "BTCUSDT")
ACCOUNT_USDT = float(os.getenv("ACCOUNT_USDT", "1000"))
GRID_LEVELS = int(os.getenv("GRID_LEVELS", "3"))
GRID_SPACING_PCT = float(os.getenv("GRID_SPACING_PCT", "0.25"))
ORDER_NOTIONAL_PCT = float(os.getenv("ORDER_NOTIONAL_PCT", "0.07"))
MIN_QTY = float(os.getenv("MIN_QTY", "0.001"))
LEVERAGE = int(os.getenv("LEVERAGE", "2"))
LIVE = int(os.getenv("LIVE", "0"))
LOG_DIR = "/opt/bitunix-bot/logs"
os.makedirs(LOG_DIR, exist_ok=True)
LOG_FILE = f"{LOG_DIR}/gridbot.log"

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    handlers=[logging.FileHandler(LOG_FILE), logging.StreamHandler()]
)








def _post(endpoint, data):
    import time, hmac, hashlib, json, random, string, logging, base64, requests

    BASE = "https://fapi.bitunix.com"

    def body_json_variants(d):
        yield json.dumps(d, separators=(',', ':'))
        yield json.dumps(d, separators=(',', ':'), sort_keys=True)

    def path_variants(ep):
        ep = ep if isinstance(ep, str) else str(ep)
        if ep.startswith("/"):
            yield ep
            yield ep[1:]
        else:
            yield ep
            yield "/" + ep

    def method_variants():
        yield "POST"
        yield "post"

    def digest_variants(secret, pre_sign):
        raw = hmac.new(secret.encode(), pre_sign.encode(), hashlib.sha256).digest()
        yield raw.hex()
        yield base64.b64encode(raw).decode()

    timestamp = str(int(time.time() * 1000))
    nonces = [
        ''.join(random.choices(string.ascii_letters + string.digits, k=16)),
        timestamp
    ]

    for nonce in nonces:
        for method in method_variants():
            for path in path_variants(endpoint):
                clean_path = path[1:] if path.startswith("/") else path
                url = f"{BASE}/" + clean_path
                for bj in body_json_variants(data):
                    pre_sign = f"{timestamp}{nonce}{method}{clean_path}{bj}"
                    for sig in digest_variants(API_SECRET, pre_sign):
                        headers = {
                            "api-key": API_KEY,
                            "sign": sig,
                            "signType": "HmacSHA256",
                            "nonce": nonce,
                            "timestamp": timestamp,
                            "language": "en-US",
                            "Content-Type": "application/json"
                        }
                        try:
                            resp = requests.post(url, headers=headers, data=bj, timeout=10)
                            try:
                                j = resp.json()
                            except Exception:
                                j = {"text": resp.text, "status": resp.status_code}

                            logging.info(
                                f"SIGN TRY => method={method} path={clean_path} "
                                f"slash={'yes' if path.startswith('/') else 'no'} "
                                f"sorted={'yes' if bj != json.dumps(data, separators=(',', ':')) else 'no'} "
                                f"digest={'hex' if len(sig)==64 else 'base64'} "
                                f"nonce={'ts' if nonce==timestamp else 'rand'} -> {j}"
                            )

                            if isinstance(j, dict) and j.get('code') in (0, 200):
                                logging.info(
                                    "SIGN CHOSEN => "
                                    f"method={method} path={clean_path} "
                                    f"slash={'yes' if path.startswith('/') else 'no'} "
                                    f"sorted={'yes' if bj != json.dumps(data, separators=(',', ':')) else 'no'} "
                                    f"digest={'hex' if len(sig)==64 else 'base64'} "
                                    f"nonce={'ts' if nonce==timestamp else 'rand'}"
                                )
                                return j

                        except Exception as e:
                            logging.error(f"SIGN variant error: {e}")

    return {"code": -1, "msg": "Signature failed for all variants"}
                        except Exception as e:
                            logging.error(f"SIGN variant error: {e}")

    return {"code": -1, "msg": "Signature failed for all variants"}
                            # for leverage set, some gateways return 200 + msg; treat code==200 as tentative success
                            if isinstance(j, dict) and j.get('code') in (0, 200):
                                logging.info("SIGN CHOSEN (code 200) => " +
                                             f"method={method} path={clean_path} slash={'yes' if path.startswith('/') else 'no'} "
                                             f"sorted={'yes' if bj != json.dumps(data, separators=(',', ':')) else 'no'} "
                                             f"digest={'hex' if len(sig)==64 else 'base64'} nonce={'ts' if nonce==timestamp else 'rand'}")
                                return j
                        except Exception as e:
                            tried.append(str(e))

    # If all attempts failed, return last response-style info
    return {"code": -1, "msg": "Signature failed for all variants", "tried": tried[:5]}
    except Exception as e:
        return {"error": str(e), "text": resp.text, "status": resp.status_code}
    except Exception as e:
        return {"error": str(e), "text": resp.text, "status": resp.status_code}
    except Exception as e:
        return {"error": str(e), "text": resp.text, "status": resp.status_code}
    except Exception:
        return {"error": resp.text, "status": resp.status_code}


def get_price(symbol):
    try:
        import requests
        r = requests.get(f"{BASE_URL}/api/v1/futures/market/tickers",
                         params={"symbols": symbol}, timeout=10)
        j = r.json()
        data = j.get("data")
        if isinstance(data, list) and data:
            item = next((x for x in data if str(x.get("symbol")) == symbol), data[0])
            last = item.get("last") or item.get("lastPrice") or item.get("price")
            if last is not None:
                return float(last)
        logging.error(f"Unexpected ticker payload: {j}")
    except Exception as e:
        logging.error(f"Ticker fetch failed: {e}")
    return None

def log_trade(mode, symbol, side, price, size, **meta):
    path = f"{LOG_DIR}/trades.csv"
    new = not os.path.exists(path)
    with open(path, "a") as f:
        if new:
            f.write("timestamp,mode,symbol,side,price,size,meta\n")
        f.write(f"{datetime.utcnow().isoformat()},{mode},{symbol},{side},{price},{size},{json.dumps(meta)}\n")

def change_leverage(symbol, leverage):
    body = {"symbol": symbol, "leverage": int(leverage), "marginCoin": "USDT"}
    try:
        j = _post("/api/v1/futures/account/change_leverage", body)
        logging.info(f"Leverage API response: {j}")
        if j.get("code") == 0:
            logging.info(f"✓ Leverage set to {leverage}x for {symbol}")
        return j
    except Exception as e:
        raise RuntimeError({"error": str(e), "body": body})

def place_order(symbol, side, price, size):
    body = {
        "symbol": symbol,
        "price": round(price, 2),
        "size": float(size),
        "side": side,
        "orderType": "limit",
        "marginCoin": "USDT"
    }
    if not LIVE:
        logging.info(f"[DRY RUN] {side} {size} {symbol} @ {price}")
        try:
            log_trade("DRY", symbol, side, price, size)
        except Exception:
            pass
        return {"dry_run": True, "body": body}
    try:
        j = _post("/api/v1/futures/order/place_order", body)
        logging.info(f"Order API response: {j}")
        try:
            rid = str(j.get("data") or j.get("orderId") or j.get("id") or "")
            log_trade("LIVE", symbol, side, price, size, resp_id=rid)
        except Exception:
            pass
        return j
    except Exception as e:
        raise RuntimeError({"error": str(e), "body": body})

def main():
    logging.info(f"{'LIVE' if LIVE else 'DRY-RUN'} GRIDBOT for {SYMBOL} started")
    price = get_price(SYMBOL)
    if not price:
        logging.error("Cannot fetch current price — exiting")
        return
    mid = price
    notional = ACCOUNT_USDT * ORDER_NOTIONAL_PCT
    size = max(MIN_QTY, notional / mid)
    spacing = GRID_SPACING_PCT / 100.0
    orders = []
    for i in range(1, GRID_LEVELS + 1):
        down = mid * (1 - spacing * i)
        up = mid * (1 + spacing * i)
        orders.append({"side": "buy", "price": down, "size": size})
        orders.append({"side": "sell", "price": up, "size": size})
    logging.info(f"Placing {len(orders)} orders around mid={mid:.2f}")
    for o in orders:
        place_order(SYMBOL, o["side"], o["price"], o["size"])
    logging.info("Grid placement complete.")

if __name__ == "__main__":
    try:
        change_leverage(SYMBOL, LEVERAGE)
        main()
    except KeyboardInterrupt:
        logging.warning("Interrupted by user.")
    except Exception as e:
        logging.error(f"Fatal: {e}")
